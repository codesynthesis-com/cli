// This code was generated by CLI, a command line interface
// compiler for C++.
//

#ifndef OPTIONS_HXX
#define OPTIONS_HXX

#include <iosfwd>
#include <string>
#include <exception>

namespace cli
{
  class unknown_mode
  {
    public:enum value
    {
      skip,
      stop,
      fail
    };

    unknown_mode (value v)
    : v_ (v) 
    {
    }

    operator value () const 
    {
      return v_;
    }

    private:
    value v_;
  };

  // Exceptions.
  //

  class exception: public std::exception
  {
    public:
    virtual void
    print (std::ostream&) const = 0;
  };

  inline std::ostream&
  operator<< (std::ostream& os, const exception& e)
  {
    e.print (os);
    return os;
  }

  class unknown_option: public exception
  {
    public:
    virtual
    ~unknown_option () throw ();

    unknown_option (const std::string& option)
    : option_ (option)
    {
    }

    const std::string&
    option () const
    {
      return option_;
    }

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
  };

  class unknown_argument: public exception
  {
    public:
    virtual
    ~unknown_argument () throw ();

    unknown_argument (const std::string& argument)
    : argument_ (argument)
    {
    }

    const std::string&
    argument () const
    {
      return argument_;
    }

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string argument_;
  };

  class missing_value: public exception
  {
    public:
    virtual
    ~missing_value () throw ();

    missing_value (const std::string& option)
    : option_ (option)
    {
    }

    const std::string&
    option () const
    {
      return option_;
    }

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
  };

  class invalid_value: public exception
  {
    public:
    virtual
    ~invalid_value () throw ();

    invalid_value (const std::string& option,
                   const std::string& value)
    : option_ (option),  value_ (value)
    {
    }

    const std::string&
    option () const
    {
      return option_;
    }

    const std::string&
    value () const
    {
      return value_;
    }

    virtual void
    print (std::ostream&) const;

    virtual const char*
    what () const throw ();

    private:
    std::string option_;
    std::string value_;
  };
}

#include <string>

#include <vector>

class options
{
  public:

  options (int argc,
           char** argv,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int start,
           int argc,
           char** argv,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int argc,
           char** argv,
           int& end,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  options (int start,
           int argc,
           char** argv,
           int& end,
           ::cli::unknown_mode option = ::cli::unknown_mode::fail,
           ::cli::unknown_mode argument = ::cli::unknown_mode::stop);

  // Option accessors.
  //
  public:

  bool const&
  help () const;

  bool const&
  version () const;

  std::string const&
  output_dir () const;

  private:
  int
  _parse (int start,
          int argc,
          char** argv,
          ::cli::unknown_mode option,
          ::cli::unknown_mode argument);

  public:
  bool help_;
  bool version_;
  std::string output_dir_;
};

#endif // OPTIONS_HXX
